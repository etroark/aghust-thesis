#pragma once

#include "libs.h"

/**
 * shader class (shader - a computer program that calculates the appropriate levels of light, darkness, and color during the rendering of a 3D scene)
 */
class Shader
{
	GLuint _id;	/**< shader ID*/
	const int _versionMajor;	/**< OpenGL major version*/
	const int _versionMinor;	/**< OpenGL minor version*/

	GLuint _vertexShader = 0;	/**< programmable shader stage in the rendering pipeline that handles the processing of individual vertices*/
	//GLuint _geometryShader = 0;	/**< a shader program written in GLSL that governs the processing of primitives (optional)*/
	GLuint _fragmentShader = 0;	/**< the shader stage that will process a fragment generated by the rasterization into a set of colors and a single depth value*/

	/**
	 * loads GLSL file and matches it to correct OpenGL version
	 * @param filename GLSL file name
	 * @return GLSL file contents
	 */
	std::string loadShaderSource(const char* fileName);
	/**
	 * creates shader object and returns a value by which it can be referenced (uses loadShaderSource method)
	 * @param type shader type
	 * @param filename GLSL file name
	 * @return empty shader object's ID
	 */
	GLuint loadShader(GLenum type, const char* fileName);
	/**
	 * creates program ID, attaches all shaders to it and links them to it
	 * @param vertexShader vertex shader ID
	 * @param geometryShader geometry shader ID
	 * @param fragmentShader fragment shader ID
	 */
	void linkProgram(GLuint vertexShader, GLuint fragmentShader);

public:

	/**
	 * creates shader program
	 * @param versionMajor OpenGL major version
	 * @param versionMinor OpenGL minor version
	 * @param vertexFile vertex core GLSL file name
	 * @param fragmentFile fragment core GLSL file name
	 * @param geometryFile geometry core GLSL file name
	 */
	Shader(const int versionMajor, const int versionMinor, const char* vertexFile, const char* fragmentFile);

	/**
	 * destructor
	 */
	inline ~Shader() { glDeleteProgram(_id); }

	/**
	 * use the program
	 */
	inline void use() { glUseProgram(_id); }
	/**
	 * unuse the program
     */
	inline void unuse() { glUseProgram(0); }

	/**
	 * set integer uniform function (uniform - a global shader variable; acts as parameter that the user of a shader program can pass to the program)
	 * @param value a shader variable value
	 * @param name of the variable in the GLSL source code
	 */
	inline void set1i(GLint value, const GLchar* name)
	{
		use();
		glUniform1i(glGetUniformLocation(_id, name), value);
		unuse();
	}

	/**
	 * set float uniform function
	 * @param value a shader variable value
	 * @param name of the variable in the GLSL source code
	 */
	inline void set1f(GLfloat value, const GLchar* name)
	{
		use();
		glUniform1f(glGetUniformLocation(_id, name), value);
		unuse();
	}

	/**
	 * set vector of 3 floats uniform function
	 * @param value a shader variable value
	 * @param name of the variable in the GLSL source code
	 */
	inline void setVec3f(glm::fvec3 value, const GLchar* name)
	{
		use();
		glUniform3fv(glGetUniformLocation(_id, name), 1, glm::value_ptr(value));
		unuse();
	}

	/**
	 * set vector of 4 floats uniform function
	 * @param value a shader variable value
	 * @param name of the variable in the GLSL source code
	 */
	inline void setVec4f(glm::fvec4 value, const GLchar* name)
	{
		use();
		glUniform4fv(glGetUniformLocation(_id, name), 1, glm::value_ptr(value));
		unuse();
	}

	/**
	 * set matrix of 3x3 floats uniform function
	 * @param value a shader variable value
	 * @param name of the variable in the GLSL source code
	 * @param transpose by default the matrix is not transposed
	 */
	inline void setMat3fv(glm::mat3 value, const GLchar* name, GLboolean transpose = GL_FALSE)
	{
		use();
		glUniformMatrix3fv(glGetUniformLocation(_id, name), 1, transpose, glm::value_ptr(value));
		unuse();
	}

	/**
	 * set matrix of 4x4 floats uniform function
	 * @param value a shader variable value
	 * @param name of the variable in the GLSL source code
	 * @param transpose by default the matrix is not transposed
	 */
	inline void setMat4fv(glm::mat4 value, const GLchar* name, GLboolean transpose = GL_FALSE)
	{
		use();
		glUniformMatrix4fv(glGetUniformLocation(_id, name), 1, transpose, glm::value_ptr(value));
		unuse();
	}
};